<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Web Pixel</title>
        <!-- Add an empty script tag for GTM to use as reference -->
        <script></script>
        <script>
            let messagePort = null;
            let debugReceiver = null;

            // Create the debug API object that will be returned for any frame access
            const debugApiObject = {
                setReceiver: function(receiver) {
                    debugReceiver = receiver;
                },
                sendMessage: function(message) {
                    if (messagePort) {
                        messagePort.postMessage({
                            type: 'GTM_DEBUG_MESSAGE',
                            data: message
                        });
                    }
                }
            };

            // Create a proxy handler for window properties
            const proxyHandler = {
                get: function(target, prop) {
                    // Special handling for 'parent', 'top', and 'frames' properties
                    if (prop === 'parent' || prop === 'top' || prop === 'frames') {
                        return new Proxy(window, {
                            get: function(target, prop) {
                                if (prop === 'debugBadgeApi') {
                                    return debugApiObject;
                                }
                                return target[prop];
                            },
                            set: function(target, prop, value) {
                                if (prop === 'debugBadgeApi') {
                                    // Ignore attempts to set debugBadgeApi
                                    return true;
                                }
                                target[prop] = value;
                                return true;
                            }
                        });
                    }
                    return target[prop];
                }
            };

            // Function to proxy an iframe's contentWindow
            function proxyIframeContentWindow(iframe) {
                if (iframe instanceof HTMLIFrameElement) {
                    Object.defineProperty(iframe, 'contentWindow', {
                        get: function() {
                            const originalContentWindow = HTMLIFrameElement.prototype.contentWindow.get.call(this);
                            return new Proxy(originalContentWindow || {}, {
                                get: function(target, prop) {
                                    if (prop === 'debugBadgeApi') {
                                        return debugApiObject;
                                    }
                                    return target[prop];
                                },
                                set: function(target, prop, value) {
                                    if (prop === 'debugBadgeApi') {
                                        return true;
                                    }
                                    try {
                                        target[prop] = value;
                                    } catch (e) {
                                        // Ignore security errors from cross-origin access
                                    }
                                    return true;
                                }
                            });
                        },
                        configurable: true,
                        enumerable: true
                    });
                }
                return iframe;
            }

            // Override createElement to proxy iframe contentWindow
            const originalCreateElement = document.createElement;
            document.createElement = function(tagName) {
                const element = originalCreateElement.call(document, tagName);
                if (tagName.toLowerCase() === 'iframe') {
                    proxyIframeContentWindow(element);
                }
                return element;
            };

            // Override innerHTML to proxy any iframes created
            const originalInnerHTMLDescriptor = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
            Object.defineProperty(Element.prototype, 'innerHTML', {
                set: function(html) {
                    originalInnerHTMLDescriptor.set.call(this, html);
                    // After setting innerHTML, find and proxy any iframes
                    const iframes = this.getElementsByTagName('iframe');
                    Array.from(iframes).forEach(iframe => {
                        proxyIframeContentWindow(iframe);
                    });
                    return true;
                },
                get: originalInnerHTMLDescriptor.get
            });

            // Get the original contentWindow getter
            const originalContentWindowGetter = Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow').get;

            // Override the contentWindow getter on the HTMLIFrameElement prototype
            Object.defineProperty(HTMLIFrameElement.prototype, 'contentWindow', {
                get: function() {
                    const originalContentWindow = originalContentWindowGetter.call(this);
                    return new Proxy(originalContentWindow || {}, {
                        get: function(target, prop) {
                            if (prop === 'debugBadgeApi') {
                                return debugApiObject;
                            }
                            return target[prop];
                        },
                        set: function(target, prop, value) {
                            if (prop === 'debugBadgeApi') {
                                return true;
                            }
                            try {
                                target[prop] = value;
                            } catch (e) {
                                // Ignore security errors from cross-origin access
                            }
                            return true;
                        }
                    });
                },
                configurable: true,
                enumerable: true
            });

            // Listen for the MessageChannel port from parent
            window.addEventListener('message', function(event) {
                if (event.data === 'INIT_CHANNEL') {
                    messagePort = event.ports[0];
                    
                    // Apply proxy to window
                    window.top = new Proxy(window, proxyHandler);
                    window.parent = new Proxy(window, proxyHandler);
                    window.frames = new Proxy(window, proxyHandler);

                    // Initialize GTM with original snippet
                    (function(w,d,s,l,i){
                        w[l]=w[l]||[];
                        w[l].push({
                            'gtm.start': new Date().getTime(),
                            event:'gtm.js'
                        });
                        var f=d.getElementsByTagName(s)[0],
                        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
                        j.async=true;
                        j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;
                        f.parentNode.insertBefore(j,f);
                    })(window,document,'script','dataLayer','GTM-T36KSSBM');
                }
            });
        </script>
    </head>
    <body>
        <!-- Google Tag Manager (noscript) -->
        <noscript>
            <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T36KSSBM" height="0" width="0" style="display:none;visibility:hidden"></iframe>
        </noscript>
        <!-- End Google Tag Manager (noscript) -->
    </body>
</html>